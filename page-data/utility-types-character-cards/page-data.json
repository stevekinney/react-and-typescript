{"componentChunkName":"component---src-templates-lesson-template-js","path":"/utility-types-character-cards","result":{"data":{"markdownRemark":{"html":"<p>We'll start from this <a href=\"https://codesandbox.io/s/character-sheet-utility-types-base-48cqu\">base</a>.</p>\n<p>We can do a quick refactor make our <code class=\"language-text\">TableRow</code> components better. This is what they look like right now.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TableProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> children<span class=\"token operator\">:</span> React<span class=\"token punctuation\">.</span>ReactNode <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TableRowProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  heading<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>It would be cool if I could enforce that the heading be property that is actually on a character.</p>\n<p>Yes. I could hardcode in the values, but I don't love that.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TableRowProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  heading<span class=\"token operator\">:</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Name\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Alignment\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Intelligence\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Strength\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Speed\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Durability\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Power\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Combat\"</span>\n    <span class=\"token operator\">|</span> <span class=\"token string\">\"Total\"</span><span class=\"token punctuation\">;</span>\n  value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This is problematic because the properties on the <code class=\"language-text\">CharacterType</code> could change and then we'd have the potential for an error in our code. It would be better if we could determine the keys eligble to be a row heading dynamically based off of <code class=\"language-text\">CharacterType</code> right?</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TableRowProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  heading<span class=\"token operator\">:</span> <span class=\"token keyword\">keyof</span> CharacterType<span class=\"token punctuation\">;</span>\n  value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This gets us most of the way there, with some small issue. It's expecting lowercase headings.</p>\n<p>We could handle this a few different ways:</p>\n<ul>\n<li>Capitalize the heading with JavaScript.</li>\n<li>Capitalize the heading with CSS.</li>\n<li>Fix the typing.</li>\n</ul>\n<p>Since this is a course of TypeScript, we're going to go with the third option.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TableRowProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  heading<span class=\"token operator\">:</span> Capitalize<span class=\"token operator\">&lt;</span><span class=\"token keyword\">keyof</span> CharacterType<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now everything works. (ESLint in CodeSandbox might be a little upset with us, but that's not our concern right now.)</p>\n<p>We can even dynamically type the <code class=\"language-text\">value</code> to be any reasonable type found in the <em>values</em> of <code class=\"language-text\">CharacterType</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TableRowProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  heading<span class=\"token operator\">:</span> Capitalize<span class=\"token operator\">&lt;</span><span class=\"token keyword\">keyof</span> CharacterType<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  value<span class=\"token operator\">:</span> CharacterType<span class=\"token punctuation\">[</span><span class=\"token keyword\">keyof</span> CharacterType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The completed example can be found <a href=\"https://codesandbox.io/s/character-sheet-utility-types-complete-jb8d4?file=/src/Table.tsx\">here</a>.</p>","frontmatter":{"path":"/utility-types-character-cards","title":"Refactoring the Character Cards with Utility Types","order":"6C","section":"Helpful TypeScript Concepts","description":"A quick rundown of some of the built-in type helpers and whatnot."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"5D","path":"/refactoring-color-inputs","title":"Refactoring the Color Inputs"}}},{"node":{"frontmatter":{"order":"3E","path":"/class-based-components","title":"Typing Class-based Components"}}},{"node":{"frontmatter":{"order":"6C","path":"/utility-types-character-cards","title":"Refactoring the Character Cards with Utility Types"}}},{"node":{"frontmatter":{"order":"2C","path":"/commonly-used-props","title":"Commonly-Used Props"}}},{"node":{"frontmatter":{"order":"5B","path":"/context-api","title":"The Context API"}}},{"node":{"frontmatter":{"order":"99A","path":"/context-exercise","title":"OLD: Context API (Exercise)"}}},{"node":{"frontmatter":{"order":"99A","path":"/context-solution","title":"OLD Context API Solution"}}},{"node":{"frontmatter":{"order":"5C","path":"/context-with-reducer","title":"The Context API with State Management"}}},{"node":{"frontmatter":{"order":"9D","path":"/dependent-props","title":"Demanding Props Based on Other Props"}}},{"node":{"frontmatter":{"order":"3E","path":"/dog-facts","title":"Exercise: Dog Facts"}}},{"node":{"frontmatter":{"order":"3D","path":"/forms-and-events","title":"Forms and Events"}}},{"node":{"frontmatter":{"order":"6A","path":"/generics","title":"Working with Generics"}}},{"node":{"frontmatter":{"order":"8B","path":"/higher-order-components-exercise","title":"Higher Order Components with TypeScript"}}},{"node":{"frontmatter":{"order":"8C","path":"/higher-order-components-solution","title":"Higher Order Components (Solution)"}}},{"node":{"frontmatter":{"order":"8A","path":"/higher-order-components","title":"Higher Order Components with TypeScript"}}},{"node":{"frontmatter":{"order":"9A","path":"/limiting-props","title":"Limiting Props a Component Can Take Based on Other Props"}}},{"node":{"frontmatter":{"order":"10A","path":"/migration","title":"Migrating From JavaScript"}}},{"node":{"frontmatter":{"order":"7C","path":"/omit","title":"Omitting Props from a Type"}}},{"node":{"frontmatter":{"order":"9C","path":"/overloads","title":"Function Overloads"}}},{"node":{"frontmatter":{"order":"5A","path":"/passing-dipatch","title":"Prologue: Passing Dispatch as a Props"}}},{"node":{"frontmatter":{"order":"9B","path":"/polymorphic-components","title":"Polymorphic Components with TypeScript"}}},{"node":{"frontmatter":{"order":"4B","path":"/reducers-exercise","title":"Reducers (Exercise)"}}},{"node":{"frontmatter":{"order":"4C","path":"/reducers-solution","title":"Reducers (Solution)"}}},{"node":{"frontmatter":{"order":"4A","path":"/reducers","title":"Typing Reducers"}}},{"node":{"frontmatter":{"order":"2B","path":"/refactoring-from-proptypes","title":"Refactoring from PropTypes"}}},{"node":{"frontmatter":{"order":"1B","path":"/sales-pitch","title":"Why Use TypeScript? (A Sales Pitch)"}}},{"node":{"frontmatter":{"order":"2A","path":"/the-most-basic-example","title":"The Very Basics"}}},{"node":{"frontmatter":{"order":"6G","path":"/type-template-literals-refactoring-adjustment-actions","title":"Type Template Literals: Refactoring Our Color Adjustment Actions"}}},{"node":{"frontmatter":{"order":"6F","path":"/type-template-literals","title":"Type Template Literals"}}},{"node":{"frontmatter":{"order":"10B","path":"/types-versus-interfaces","title":"Types Versus Interfaces"}}},{"node":{"frontmatter":{"order":"2E","path":"/typing-children-solution","title":"Typing Children (Solution)"}}},{"node":{"frontmatter":{"order":"2D","path":"/typing-children","title":"Typing Children"}}},{"node":{"frontmatter":{"order":"2F","path":"/typing-styling","title":"Typing Styling"}}},{"node":{"frontmatter":{"order":"3C","path":"/use-effect","title":"useEffect"}}},{"node":{"frontmatter":{"order":"3B","path":"/use-state-no-default-value","title":"Setting State without a Default Value"}}},{"node":{"frontmatter":{"order":"3A","path":"/use-state","title":"useState Hook"}}},{"node":{"frontmatter":{"order":"6D","path":"/utility-types-exercise","title":"Utility Types (Exercise)"}}},{"node":{"frontmatter":{"order":"6E","path":"/utility-types-solution","title":"Utility Types (Solution)"}}},{"node":{"frontmatter":{"order":"6B","path":"/utility-types","title":"A Tour of Utility Types in React"}}},{"node":{"frontmatter":{"order":"1A","path":"/welcome","title":"Welcome and Introduction"}}},{"node":{"frontmatter":{"order":"99B","path":"/wrapping-an-element","title":"Wrapping and Element"}}},{"node":{"frontmatter":{"order":"7B","path":"/wrapping-components","title":"Wrapping Components"}}},{"node":{"frontmatter":{"order":"7A","path":"/wrapping-elements","title":"Wrapping HTML Elements"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}